# JVM classloader
- class文件装载过程
	- 加载
	- 连接
		- 验证
		- 准备
		- 解析
	- 初始化

- 类加载的条件
	- 一个类或借口在初次主动使用前，必须要进行初始化。主动使用是指
		- 当创建一个类的实例时。
			- new
			- 反射
			- 克隆
			- 反序列化
		- 调用静态方法
		- 使用非final的静态字段
		- 使用反射包中的方法反射类的方法
		- 初始化子类时，先初始化父类
		- main方法所在类
	- -XX:+TraceClassLoading 单独跟踪类的加载
	- 参考SimpleLoad.java

- 加载类
	- 通过类的全名，获取类的二进制数据流
	- 把类的二进制数据流解析为方法区的数据结构
	- 创建java.lang.Class类的实例

- 验证类
	- 格式检查
		- 魔数检查
		- 版本检查
		- 长度检查
	- 语义检查
		- 是否集成final
		- 是否有父类
		- 是否实现了抽象方法
	- 字节码验证
		- 跳转指令是否指向正确位置
		- 操作数类型是否合理
	- 符号引用验证
		- 符号引用的直接引用是否存在
	- ide实时编译，一般都会有提示

- 准备
	- 分配内存，设置初始值
	- 设置常量值
 
- 解析类
	- 将类、接口、字段和方法的符号引用转为直接引用

- 初始化
	- 执行<clinit>
		- 会视图加载该类的父类

- ClassLoader
	- 分类
		- BootStrap ClassLoader 启动类加载器
			 - C编写，没有Java对象与之对应，加载系统核心类（比如String、rt.jar）
		- Extension ClassLoader 扩展类加载器
			- 用于加载JAVA_HOME/lib/ext/*.jar
		- App ClassLoader 应用类加载器
			- 用于加载用户类
		- 自定义的ClassLoader
			- 加载一些特殊途径的类，一般也是用户类
	- 自顶向下启动ClassLoader
	- 自底向上检查类是否加载 
	- 双亲委托模式
		- 类加载的时候，系统会判断当前类是否被加载，如果已经被加载，直接返回可用的类。
		- 如果没加载，则尝试加载，会先请求双亲处理，如果双亲请求失败，则会自行加载。
		- 弊端
			- 自底向上检查类加载，顶层的ClassLoader无法访问底层的ClassLoader所加载的类
			- 例如jdbc的api需要调用应用类加载器的jdbc驱动
		- 解决方式
			- Thread实例的setContextClassLoader方法
			- 把一个ClassLoader置于一个线程实例当中，使该ClassLoader成为一个相对共享的实例，一般情况下，上下文加载器就是应用加载器这样即使在启动类加载器中的代码也可以通过这种方式访问应用加载器中的类了。
		- 突破双亲模式
			- 通过重载java.lang.ClassLoader类中的loadClass方法实现
		- 热替换
			- 不同的ClassLoader加载的同名类属于不同类型，不能相互转化和兼容
			- 两个不同ClassLoader加载同一个类，在虚拟机内部，会认为这两个类是完全不同的
			- 通过重载java.lang.ClassLoader类的findClass方法实现
			- URLClassLoader