# JVM classloader
- class文件装载过程
	- 加载
	- 连接
		- 验证
		- 准备
		- 解析
	- 初始化

- 类加载的条件
	- 一个类或借口在初次主动使用前，必须要进行初始化。主动使用是指
		- 当创建一个类的实例时。
			- new
			- 反射
			- 克隆
			- 反序列化
		- 调用静态方法
		- 使用非final的静态字段
		- 使用反射包中的方法反射类的方法
		- 初始化子类时，先初始化父类
		- main方法所在类
	- -XX:+TraceClassLoading 单独跟踪类的加载
	- 参考SimpleLoad.java

- 加载类
	- 通过类的全名，获取类的二进制数据流
	- 把类的二进制数据流解析为方法区的数据结构
	- 创建java.lang.Class类的实例

- 验证类
	- 格式检查
		- 魔数检查
		- 版本检查
		- 长度检查
	- 语义检查
		- 是否集成final
		- 是否有父类
		- 是否实现了抽象方法
	- 字节码验证
		- 跳转指令是否指向正确位置
		- 操作数类型是否合理
	- 符号引用验证
		- 符号引用的直接引用是否存在
	- ide实时编译，一般都会有提示

- 准备
	- 分配内存，设置初始值
	- 设置常量值
 
- 解析类
	- 将类、接口、字段和方法的符号引用转为直接引用

- 初始化
	- 执行<clinit>
		- 会视图加载该类的父类

- ClassLoader
	- 分类
		- BootStrap ClassLoader 启动类加载器
			 - C编写，没有Java对象与之对应，加载系统核心类（比如String、rt.jar）
		- Extension ClassLoader 扩展类加载器
			- 用于加载JAVA_HOME/lib/ext/*.jar
		- App ClassLoader 系统类加载器
			- 用于加载用户类
		- 自定义的ClassLoader
			- 加载一些特殊途径的类，一般也是用户类
	- 自顶向下启动ClassLoader
	- 自底向上检查类是否加载 
	- 双亲委托模式
		- 类加载的时候，系统会判断当前类是否被加载，如果已经被加载，直接返回可用的类。
		- 如果没加载，则尝试加载，会先请求双亲处理，如果双亲请求失败，则会自行加载。
		- 弊端
			- 自底向上检查，系统类无法访问应用类