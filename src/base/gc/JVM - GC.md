
# JVM GC
- 常用GC算法
	- 引用计数法
		- 原理
			- 对象被引用即在整型引用计数器上+1；
		- 问题
			- 无法处理循环引用；
			- 每次对象生成或回收都必须需要进行加或减的运算操作；
	- 标记清除法
		- 原理
			- 标记阶段：通过根节点，标记所有根节点开始的可达对象；
			- 清除阶段，清除未在标记阶段标记的对象；
		- 问题
			- 回收后产生内存碎片，内存不连续，导致性能降低；
	- 复制算法
		- 原理
			- 将内存一分为二，每次只操作一块内存进行回收，将存活对象复制到另一块内存中，然后清楚当前内存中的垃圾对象。
			- 不会产生内存碎片。
		- 问题
			- 内存折半
		- 应用
			- Java新生代使用复制算法的思想
				- copy eden -> s0 s1 -> s0 if(obj.size > s0.size or s0.full) -> tenur 
				- gc eden s1
	- 标记压缩法
		- 原理
			- 优化标记清除算法，在完成清除算法后，将剩余的存活对象移动到内存一段，避免内存碎片的产生
		- 问题
			- gc时的开销比标记清除法大
		- 应用
			- 老年代的gc
	- 分代算法
		- 新生代 复制算法，因为会有大量的对象会被回收，复制的代价很小。
			- 卡表 比特位集合，记录每4KB的老年代空间中是否有对象持有新生代的引用（有记1，无记0），这样就不用扫描全部的老年代对象而只需要扫卡表。提高新生代的gc效率
		- 老年代 标记清除或标记压缩
	- 分区算法
		- 原理
			- 将整个堆空间划分成连续的不同小区间，每个小区间都独立使用，独立回收。这种算法的好处在于可以控制一次回收多少个小区间。

- 可触及性
	- 可触及的
		- 从根节点开始扫描，可以到达这个对象
	- 可复活的
		- 对象实现了finalize方法，在对象的所有引用都释放后，对象有可能复活
	- 不可触及的
		- 对象的finalize方法已经被调用过，并且未复活，进入不可触及状态，对象只有在该状态才能被回收
		- 参考ObjCanRelive.java
		
- 引用和可触及性强度
	- 强引用
		- 程序中一般使用的引用类型，强引用的对象是可触及的，不会回收的。
	- 软引用
		- 在堆空间不足时会被回收的引用
			- 参考SoftRef.java
		- 软引用队列：在可达性从可达变为不可达时，软引用的对象就会进入该队列，可以通过这个队列跟踪对象的回收情况
			- 参考SoftRefQ.java
	- 弱引用
		- gc时发现即回收
			- 参考WeakRef.java
		- 弱引用也有队列，原理同软引用
		- 弱引用和软引用常用来实现一些不重要的缓存，合理利用可以减少OOM发生的可能性
	- 虚引用
		- 资源释放操作

- STW