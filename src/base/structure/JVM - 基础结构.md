
# JVM的基本结构
- 类加载子系统
	- 加载Class信息，加载的信息存在方法区里。
- Java栈
	- 线程私有空间，栈帧、局部变量、方法参数、引用。 
- 方法区
	- 存放Class信息，运行时常量池，String的字面量和数字常量 
- Java堆
	- 主要工作区域，所有的对象实例都在堆里，堆空间是所有线程共享的。 
- 直接内存
	- 堆外内存，需通过NIO进行访问，直接内存的访问性能优于堆内存，适合在读写频繁的场景下使用，但一般只有在GC时才能释放，释放时间是确定的。
- 本地方法栈
	- 调用计算机上的本地方法 
- 垃圾回收系统
	- 负责隐式地回收方法区，堆，直接内存
- PC寄存器
	- 线程私有空间，它会指向线程正在执行的当前方法，如果是本地方法，PC寄存器的值是undefined
- 执行引擎
	- 执行虚拟机字节码。

# JAVA堆的基本结构
- 新生代、老年代  
	- eden、s0、s1、tenured
		- 对象初生一般都分配在eden中，经过一次新生代回收后，如果对象还存活，进入s0或s1，每次回收会使得对象的年龄+1，到达一定次数后，进入老年代。
		- 控制进入老年代的参数为 
			- -XX:MaxTenuringThreshold=15
	
# JAVA栈
- 线程私有的内存空间，线程执行的基本行为是函数调用，每次调用都需要通过Java栈来进行传递。
- LIFO的数据结构，最里层被调用的方法（最后被压入栈的方法）会最先返回结果。
- 栈帧的结构
	- 一个栈帧中包含了局部变量表、操作数栈和帧数据区
		- 局部变量表
			- 局部变量是占用栈大小的。
				- 参考TestStackDepthWithSomeLocalVariables.java
			- 可以使用jclasslib工具查看局部变量表。
			- 局部变量表的槽位是可复用的，当一个局部变量不在作用时，原来他使用的槽位会被其他还在作用中的局部变量复用
			- 局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象是不会被回收的。
				- 参考TestLocalVarGC.java
		- 操作数栈
			- 保存栈帧中计算过程的中间结果
			- 操作数栈也是一个LIFO的数据结构
		- 帧数据区
			- 保存访问常量池的指针
			- 异常处理表，用于告诉栈帧，如果发生异常后，该从哪里开始继续执行方法
- 栈的大小设置
	- -Xss
- 无出口的递归必然会导致StackOverflowError，参考TestStackDepth.java。
- 栈上分配
	- 对于线程私有的对象，可以直接分配在栈上，这样栈帧销毁即释放了空间，GC不会介入，提高程序效率
	- 逃逸分析
		- 判断对象的作用域是否有可能逃逸出函数体，只要未发生对象逃逸，那这个对象就有可能被分配在栈上
		- 参考TestOnStack.java
		- -XX:+DoEscapeAnalysis 只有在server模式下可开启，server模式下默认开启
	- 标量替换
		- 原始数据类型int、long、double这些不能被继续分解，所以称为标量。
		- 如果一个数据可以继续分解，那它称为聚合量，对象是典型的聚合量。
		- 如果一个对象被确定为非逃逸，那在运行时，他就会被分解为标量。从而进行栈上分配。
		- -XX:+EliminateAllocations 默认开启
	- 参考TestOnStack.java。


